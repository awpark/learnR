---
title: "Data wrangling"
author: "Andrew W. Park"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r, echo=F, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(learnr)
```

## Learning outcomes

1. Reading in data

2. "Tidy" data

3. Piping and applying functions to rows

## Introduction

This is the third in a series of five exercises that constitute _Training Module 1: Introduction to Scientific Programming_, taught through the IDEAS PhD program at the University of Georgia Odum School of Ecology in conjunction with the Center for the Ecology of Infectious Diseases. 

This exercise explores methods of data wrangling, which is essentially the good practices associated with storing and manipulating data. This module uses the libraries `tidyverse` and `magrittr`. Load these libraries.

```{r libLoad, exercise=TRUE, exercise.eval=TRUE, message=FALSE, warning=FALSE}

```


```{r libLoad-solution}
library(tidyverse)
library(magrittr)
```

## Case study

Lyme disease is a tick-borne emerging infectious disease in the US dating back to the 1970s and caused by a bacteria called _Borrelia burgdorferi_. It is thought to infect hundreds of thousands of people each year, though not all cases get reported. The distribution of cases of Lyme across the US is incompletely understood to this day. We'll be working with three distinct data sets

* The US census data (population size) 2000-2014 by county 'pop.csv'
* The CDC public-use data set on Lyme disease cases 2000-2015 by county 'lyme.csv'
* The PRISM data set, which contains commonly-used climate variables, 2000-2015, by county 'climate.csv'

Our ultimate research goal is to better understand the relationship between climate, population size and Lyme disease cases. Our scientific programming goals are to

* Import the data sets
* Convert data to the `tidy data` format
* Identify and manipulate text strings with the `regexp` language
* Merge data sets
* Visualize geographic variables as a map

In the subsequent module, we'll continue to work with these data and develop more good techniques to support hypothesis generation.

## Importing data

The Lyme disease data is relatively simple to import because the CDC maintains the data as a csv file (this data is provided to you on the workshop web page, but for your records it is available here: https://www.cdc.gov/lyme/stats/). We're going to use the `read_csv` command for loading all these data sets (not `read.csv`). The `read_csv` will create tibble versions of data frames, which retain all the good things about data frames, but not some of the less good things (more here on tibbles: https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html)

Similarly, the Census U.S. Intercensal County Population Data, 1970-2014 (also provided to you) is available from the National Bureau of Economic Research as a csv file ( http://www.nber.org/data/census-intercensal-county-population.html)

The PRISM data for total rainfall and average temperature, is available for overlapping years, 2000-2015 (http://www.prism.oregonstate.edu/). Please note: your instructors have obtained and formatted this data from PRISM in advance, as it involves some time consuming steps that are beyond the scope of this workshop (please ask in a break if you're interested in learning about this).

*Task 1: Read in the pop.csv file as a tibble data frame. For consistency, we'll assign this dataframe to be called "pop". The file is located on github at https://raw.githubusercontent.com/awpark/learnR/master/pop.csv*

```{r readData-setup, echo=FALSE, message=F, warning=FALSE}
library(tidyverse)
```


```{r readData, exercise=TRUE, exercise.eval=FALSE, message=FALSE, warning=FALSE}

```

```{r readData-solution}
pop <- read_csv("https://raw.githubusercontent.com/awpark/learnR/master/pop.csv")
```


## The `tidy data` format

Currently, only the PRISM data conforms to the concept of `tidy data`:

* Each variable has its own column
* Each observation has its own row
* Each value has its own cell

This is a highly recommended format to store data, and you can read more about why here: http://www.jstatsoft.org/v59/i10/paper. Unfortunately, it is not a standard way of storing data. Fortunately, there are tools within the R programming environment that can help us convert data to the tidy format. 

### A note about FIPS codes

In this exercise, data is organized at the county level for the US. You'll note that there is a column called `fips`. This is a number that uniquely defines a county in the US. The first 1 or 2 digits refer to the state (e.g. 6=California, 13=Georgia). The following 1-3 digits identify the counties of that state, numbered in alphabetical order, usually using only odd numbers (e.g. 59 is Clarke county, Georgia, where UGA has its main campus). The full FIPS code for Clarke county is 13059 (we 'pad' the county code with zeros to ensure it is always three digits in total - but we don't do that with states, which can be 1 or 2 digits). The format may seem a little quirky, but the system works very well in uniquely identifying counties in the US and is one of the common ways that infectious disease, climate and demographic data are organized in the US. 

*Task 2: By inspecting the 'pop' data, and talking with your neighbors and instructors, articulate in which way(s) these data fail to conform to the `tidy data` format?*

```{r inspectPop-setup, message=FALSE, warning=FALSE}
library(tidyverse)
library(magrittr)
pop <- read_csv("https://raw.githubusercontent.com/awpark/learnR/master/pop.csv")
```


```{r inspectPop, exercise=TRUE, exercise.eval=FALSE, message=FALSE, warning=FALSE}

```

```{r inspectPop-solution}
pop
```


## Methods to manipulate census data

Common to many data wrangling solutions, we will use functions from the `dplyr` package: _select_, _gather_, and _mutate_. In addition, we'll use `str_replace_all`, which is a function of the `stringr` package that replaces characters (text) with other characters. The basic call is `str_replace_all(x,y,z)` where `x` is where R should look to perform these replacements, `y` is the pattern to be replaced, and `z` is the replacing pattern.

### Testing the use of `str_replace_all`

```{r testStrRepAll-setup, echo=F}
library(tidyverse)
library(magrittr)
pets <- tibble(human=c("Abby","Ben","Chiara"),animalType=c("Fish","Dag","Harse"),animalName=c("Daisy","Alan","Hoofy"))
```


```{r displayPets, exercise=TRUE, exercise.setup="testStrRepAll-setup", waring=F, message=F}
pets
```

Run the code above to inspect the dataframe `pets`, and then write a line of code that pipes the dataframe to a `mutate` function to correct the spelling in the `animalType` column. Then inspect the dataframe again to check you fixed things.

```{r testStrRepAll, exercise=TRUE, exercise.eval=FALSE, message=FALSE, warning=FALSE}

```

```{r testStrRepAll-solution}
pets %<>% mutate(animalType = str_replace_all(animalType,"a","o"))
pets
```


### After each task below, be sure to add `pop` as the final line of code so you can see how the dataframe is evolving as you manipulate it. 

*Task 3: Streamline the `pop` dataframe using `select` so that we only retain the `fips` column and all columns that start with "pop2".*

```{r streamlinePop, exercise=TRUE, exercise.setup="inspectPop-setup", message=FALSE, warning=FALSE}

```

```{r streamlinePop-solution}
pop %<>% select(fips,starts_with("pop2"))
pop
```

```{r streamlinePop-hint-1}
pop %<>% select()
```

```{r streamlinePop-hint-2}
pop %<>% select(starts_with(...))
```


*Task 4: Use the `gather` function to collect columns starting "pop2" into two columns, where the `key` is "year" and the `value` is "size". As a final part of the pipeline, remove rows with `NA` values.*

```{r gatherPop-setup, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(magrittr)
pop <- read_csv("https://raw.githubusercontent.com/awpark/learnR/master/pop3_4.csv")
```


```{r gatherPop, exercise=TRUE, message=FALSE, warning=FALSE}

```



```{r gatherPop-solution, echo=FALSE}
pop %<>% gather(starts_with("pop2"),key="year",value="size") %>% na.omit
pop
```


*Task 5: Use `mutate`, `str_replace_all`, and `as.integer` to change cells in the year column from, for example, the character "pop2001" to the integer "2001".*

```{r wrangleYearColumn-setup, message=FALSE, warning=FALSE}
library(tidyverse)
library(magrittr)
pop <- read_csv("https://raw.githubusercontent.com/awpark/learnR/master/pop4_5.csv")
```


```{r wrangleYearColumn, exercise=TRUE, message=FALSE, warning=FALSE}

```


```{r wrangleYearColumn-solution, echo=FALSE}
pop %<>% mutate(year=str_replace_all(year,"pop","")) %>% mutate(year=as.integer(year))
pop
```

*Task 6: For later tasks, we require that the fips column doesn't have data that starts with a zero, and is integer data. To see how to do this, click the solution button, then run this code (and again add `pop` as the final line of code to see your final results).*

```{r wrangleFipsColumn-setup, message=FALSE, warning=FALSE}
library(tidyverse)
library(magrittr)
pop <- read_csv("https://raw.githubusercontent.com/awpark/learnR/master/pop5_6.csv")
```

```{r wrangleFipsColumn, exercise=TRUE, message=FALSE, warning=FALSE}

```

```{r wrangleFipsColumn-solution, echo=FALSE}
pop %<>% mutate(fips=str_replace_all(fips,"^0","")) %>% mutate(fips=as.integer(fips))
pop
```

The code is now in `tidy data` format. Great job!

## Methods to manipulate disease data

The disease data can be converted to `tidy data` format in a similar way. In addition to methods described above, we'll also write a function to help us generate consistent fips codes in the disease data set. 

*Task 7: First, read in the lyme.csv file as a tibble data frame. For consistency, we'll assign this dataframe to be called "ld" (for Lyme disease). The file is located on github at https://raw.githubusercontent.com/awpark/learnR/master/lyme.csv*

### After each task, be sure to add `ld` as the final line of code so you can see how the dataframe is evolving as you manipulate it. 

```{r readData2-setup, echo=FALSE, message=F, warning=FALSE}
library(tidyverse)
```


```{r readData2, exercise=TRUE, exercise.eval=FALSE, message=FALSE, warning=FALSE}

```

```{r readData2-solution}
ld <- read_csv("https://raw.githubusercontent.com/awpark/learnR/master/lyme.csv")
ld
```

By exploring this dataframe, you should recognize that it is not in `tidy data` format.

*Task 8: Use the `gather` function to collect columns starting "Cases" into two columns, where the `key` is "year" and the `value` is "cases". As a final part of the pipeline, remove rows with `NA` values.*

```{r gatherLd-setup, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(magrittr)
ld <- read_csv("https://raw.githubusercontent.com/awpark/learnR/master/ld7-8.csv")
```


```{r gatherLd, exercise=TRUE, message=FALSE, warning=FALSE}

```



```{r gatherLd-solution, echo=FALSE}
ld %<>% gather(starts_with("Cases"),key="year",value="cases") %>% na.omit
ld
```

*Task 9: Using `mutate`, `str_replace_all`, and `as.integer`, remove the text component of cells in the year column and convert this column to data type 'integer'.*

```{r wrangleYearColumn2-setup, message=FALSE, warning=FALSE}
library(tidyverse)
library(magrittr)
ld <- read_csv("https://raw.githubusercontent.com/awpark/learnR/master/ld8-9.csv")
```


```{r wrangleYearColumn2, exercise=TRUE, message=FALSE, warning=FALSE}

```


```{r wrangleYearColumn2-solution, echo=FALSE}
ld %<>% mutate(year=str_replace_all(year,"Cases","")) %>% mutate(year=as.integer(year))
ld
```
